{
  "simplify_expression": "def simplify_expression(self, expression: str) -> str:\n        r\"\"\"Simplifies a mathematical expression. Also can be used to\n            carry out simple computation\n\n        Args:\n            expression (str): The mathematical expression to simplify,\n                provided as a string.\n\n        Returns:\n            str: JSON string containing the simplified mathematical\n                expression in the `\"result\"` field. If an error occurs,\n                the `\"status\"` field will be set to `\"error\"` with a\n                corresponding `\"message\"`.\n\n        Raises:\n            Exception: If there is an error during the simplification\n                process, such as invalid input or unsupported syntax.\n        \"\"\"\n        try:\n            self.logger.info(f\"Simplifying expression: {expression}\")\n            expression = self._rewrite_expression(expression)\n            expr = sp.parse_expr(expression)\n            simplified = sp.simplify(expr)\n            self.logger.info(\n                f\"Result of simplified expression: {simplified!s}\"\n            )\n            return json.dumps({\"status\": \"success\", \"result\": str(simplified)})\n        except Exception as e:\n            self.logger.error(\n                f\"Error simplifying expression: {expression} - {e}\"\n            )\n            return json.dumps({\"status\": \"error\", \"message\": str(e)})",
  "expand_expression": "def expand_expression(self, expression: str) -> str:\n        r\"\"\"Expands an algebraic expression.\n\n        Args:\n            expression (str): The algebraic expression to expand,\n                provided as a string.\n\n        Returns:\n            str: JSON string containing the expanded algebraic expression\n                in the `\"result\"` field. If an error occurs, the JSON\n                string will include an `\"error\"` field with the corresponding\n                error message.\n\n        Raises:\n            Exception: If there is an error during the expansion process,\n                such as invalid input or unsupported syntax.\n        \"\"\"\n        try:\n            self.logger.info(f\"Expanding expression: {expression}\")\n            expression = self._rewrite_expression(expression)\n            expr = sp.parse_expr(expression)\n            expanded_expr = sp.expand(expr)\n            self.logger.info(\n                f\"Result of expanded expression: {expanded_expr!s}\"\n            )\n            return json.dumps({\"result\": str(expanded_expr)})\n        except Exception as e:\n            return self.handle_exception(\"expand_expression\", e)",
  "factor_expression": "def factor_expression(self, expression: str) -> str:\n        r\"\"\"Factors an algebraic expression.\n\n        Args:\n            expression (str): The algebraic expression to factor,\n                provided as a string.\n\n        Returns:\n            str: JSON string containing the factored algebraic expression\n                in the `\"result\"` field. If an error occurs, the JSON string\n                will include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the factoring process,\n                such as invalid input or unsupported syntax.\n        \"\"\"\n        try:\n            self.logger.info(f\"Factoring expression: {expression}\")\n            expression = self._rewrite_expression(expression)\n            expr = sp.parse_expr(expression)\n            factored_expr = sp.factor(expr)\n            self.logger.info(\n                f\"Result of factored expression: {factored_expr!s}\"\n            )\n            return json.dumps({\"result\": str(factored_expr)})\n        except Exception as e:\n            return self.handle_exception(\"factor_expression\", e)",
  "solve_linear_system": "def solve_linear_system(\n        self, equations: List[str], variables: List[str]\n    ) -> str:\n        r\"\"\"Solves a system of linear equations.\n\n        Args:\n            equations (List[str]): A list of strings representing the linear\n                equations to be solved.\n            variables (List[str]): A list of strings representing the variables\n                involved in the equations.\n\n        Returns:\n            str: JSON string containing the solution to the system of equations\n                in the `\"result\"` field. Each solution is represented as\n                a tuple of values corresponding to the variables. If an\n                error occurs, the JSON string will include an `\"error\"\n                field with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the solving process, such as\n                invalid equations, incompatible variables, or an\n                unsolvable system.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"\"\"Solving linear system: {equations}\n                with variables: {variables}\"\"\"\n            )\n            equations = [self._rewrite_expression(eq) for eq in equations]\n            eqs = [sp.parse_expr(eq) for eq in equations]\n            vars = sp.symbols(variables)\n            solution = sp.linsolve(eqs, vars)\n            self.logger.info(\n                f\"Result of linear system: {[str(sol) for sol in solution]}\"\n            )\n            return json.dumps({\"result\": [str(sol) for sol in solution]})\n        except Exception as e:\n            return self.handle_exception(\"solve_linear_system\", e)",
  "solve_nonlinear_system": "def solve_nonlinear_system(\n        self, sympy_equations: List[str], variables: List[str]\n    ) -> str:\n        r\"\"\"Solves a system of nonlinear equations.\n\n        Args:\n            sympy_equations (List[str]): A list of strings representing\n                the nonlinear\n                equations to be solved. The equation to solve, must be\n                compatible with SymPy, provided as a string.\n\n            variables (List[str]): A list of strings representing the variables\n                involved in the equations.\n\n        Returns:\n            str: JSON string containing the solutions to the system of\n                equations in the `\"result\"` field. Each solution is\n                represented as a tuple of values corresponding to the\n                variables. If an error occurs, the JSON string will\n                include an `\"error\"` field with the corresponding\n                error message.\n\n        Raises:\n            Exception: If there is an error during the solving process,\n                such as invalid equations, incompatible variables, or\n                an unsolvable system.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"\"\"Solving nonlinear system: {sympy_equations}\n                with variables: {variables}\"\"\"\n            )\n            sympy_equations = [\n                self._rewrite_expression(eq) for eq in sympy_equations\n            ]\n            eqs = [sp.parse_expr(eq) for eq in sympy_equations]\n            vars = sp.symbols(variables)\n            solution = sp.nonlinsolve(eqs, vars)\n            self.logger.info(\n                f\"Result of nonlinear system: {[str(sol) for sol in solution]}\"\n            )\n            return json.dumps({\"result\": [str(sol) for sol in solution]})\n        except Exception as e:\n            return self.handle_exception(\"solve_nonlinear_system\", e)",
  "solve_univariate_inequality": "def solve_univariate_inequality(\n        self, inequality: str, variable: str\n    ) -> str:\n        r\"\"\"Solves a single-variable inequality.\n\n        Args:\n            inequality (str): A string representing the inequality\n                to be solved.\n            variable (str): The variable in the inequality.\n\n        Returns:\n            str: JSON string containing the solution to the inequality in the\n                `\"result\"` field. The solution is represented in a symbolic\n                format (e.g., intervals or expressions). If an error occurs,\n                the JSON string will include an `\"error\"` field with the\n                corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the solving process, such as\n                invalid input, unsupported syntax, or issues with the variable\n                definition.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"\"\"Solving univariate inequality: {inequality} \n                for variable: {variable}\"\"\"\n            )\n            var = sp.symbols(variable)\n            ineq = sp.parse_expr(inequality)\n            solution = sp.solve_univariate_inequality(ineq, var)\n            self.logger.info(f\"Result of univariate inequality: {solution!s}\")\n            return json.dumps({\"result\": str(solution)})\n        except Exception as e:\n            return self.handle_exception(\"solve_univariate_inequality\", e)",
  "reduce_inequalities": "def reduce_inequalities(self, inequalities: List[str]) -> str:\n        r\"\"\"Reduces a system of inequalities.\n\n        Args:\n            inequalities (List[str]): A list of strings representing the\n                inequalities to be reduced.\n\n        Returns:\n            str: JSON string containing the reduced system of inequalities\n                in the `\"result\"` field. The solution is represented in\n                a symbolic format (e.g., combined intervals or expressions).\n                If an error occurs, the JSON string will include an `\"error\"`\n                field with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the reduction process, such\n                as invalid input, unsupported syntax, or inconsistencies in the\n                inequalities.\n        \"\"\"\n        try:\n            self.logger.info(f\"Reducing inequalities: {inequalities}\")\n            ineqs = [sp.parse_expr(ineq) for ineq in inequalities]\n            solution = sp.reduce_inequalities(ineqs)\n            self.logger.info(f\"Result of reduced inequality: {solution!s}\")\n            return json.dumps({\"result\": str(solution)})\n        except Exception as e:\n            return self.handle_exception(\"reduce_inequalities\", e)",
  "polynomial_representation": "def polynomial_representation(self, expression: str, variable: str) -> str:\n        r\"\"\"Represents an expression as a polynomial.\n\n        Args:\n            expression (str): The mathematical expression to represent as\n                a polynomial, provided as a string.\n            variable (str): The variable with respect to which the polynomial\n                representation will be created.\n\n        Returns:\n            str: JSON string containing the polynomial representation of the\n                expression in the `\"result\"` field. The polynomial is returned\n                in a symbolic format. If an error occurs, the JSON string will\n                include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the polynomial conversion\n                process, such as invalid input or unsupported syntax.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"\"\"Creating polynomial representation of: {expression} \n                with variable: {variable}\"\"\"\n            )\n            expression = self._rewrite_expression(expression)\n            var = sp.symbols(variable)\n            expr = sp.parse_expr(expression)\n            poly = sp.Poly(expr, var)\n            self.logger.info(f\"Polynomial representation solution: {poly!s}\")\n            return json.dumps({\"result\": str(poly)})\n        except Exception as e:\n            return self.handle_exception(\"polynomial_representation\", e)",
  "polynomial_degree": "def polynomial_degree(self, expression: str, variable: str) -> str:\n        r\"\"\"Returns the degree of a polynomial.\n\n        Args:\n            expression (str): The polynomial expression for which the degree\n                is to be determined, provided as a string.\n            variable (str): The variable with respect to which the degree\n                of the polynomial is calculated.\n\n        Returns:\n            str: JSON string containing the degree of the polynomial in the\n                `\"result\"` field. If an error occurs, the JSON string will\n                include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the degree calculation\n                process, such as invalid input, unsupported syntax, or if\n                the expression is not a valid polynomial.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"\"\"Getting degree of polynomial: {expression} \n                with variable: {variable}\"\"\"\n            )\n            expression = self._rewrite_expression(expression)\n            var = sp.symbols(variable)\n            expr = sp.parse_expr(expression)\n            degree = int(sp.degree(expr, var))\n            self.logger.info(f\"Result of polynomial degree: {degree!s}\")\n            return json.dumps({\"result\": degree})\n        except Exception as e:\n            return self.handle_exception(\"polynomial_degree\", e)",
  "polynomial_coefficients": "def polynomial_coefficients(self, expression: str, variable: str) -> str:\n        r\"\"\"Returns the coefficients of a polynomial.\n\n        Args:\n            expression (str): The polynomial expression from which the\n                coefficients are to be extracted, provided as a string.\n            variable (str): The variable with respect to which the polynomial\n                coefficients are determined.\n\n        Returns:\n            str: JSON string containing the list of coefficients of the\n                polynomial in the `\"result\"` field. The coefficients are\n                ordered from the highest degree term to the constant term.\n                If an error occurs, the JSON string will include an `\"error\"\n                field with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the coefficient extraction\n                process, such as invalid input, unsupported syntax, or if the\n                expression is not a valid polynomial.\n        \"\"\"\n        try:\n            expression = self._rewrite_expression(expression)\n            var = sp.symbols(variable)\n            expr = sp.parse_expr(expression)\n            coeffs = sp.Poly(expr, var).all_coeffs()\n            return json.dumps({\"result\": [str(coeff) for coeff in coeffs]})\n        except Exception as e:\n            return self.handle_exception(\"polynomial_coefficients\", e)",
  "solve_equation": "def solve_equation(\n        self, sympy_equation: str, variable: Optional[str] = None\n    ) -> str:\n        r\"\"\"Solves an equation for a specific variable.\n\n        Args:\n            sympy_equation(str): The equation to solve, must be compatible\n                with SymPy, provided as a string.\n            variable (str, optional): The variable to solve for. If not\n                specified, the function will use the default variable.\n\n        Returns:\n            str: JSON string containing the solutions to the equation in the\n                `\"result\"` field. Each solution is represented as a string.\n                If an error occurs, the JSON string will include an `\"error\"`\n                field with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the solving process, such as\n                invalid input, unsupported syntax, or an undefined variable.\n        \"\"\"\n        try:\n            variable = (\n                sp.symbols(variable) if variable else self.default_variable\n            )\n            self.logger.info(\n                f\"Solving equation: {sympy_equation} for {variable}\"\n            )\n            sympy_equation = self._rewrite_expression(sympy_equation)\n            eq = sp.parse_expr(sympy_equation)\n            solutions = sp.solve(eq, variable)\n            self.logger.info(\n                f\"Result of equation: {[str(sol) for sol in solutions]}\"\n            )\n            return json.dumps({\"result\": [str(sol) for sol in solutions]})\n        except Exception as e:\n            return self.handle_exception(\"solve_equation\", e)",
  "find_roots": "def find_roots(self, expression: str) -> str:\n        r\"\"\"Finds the roots of a polynomial or algebraic equation.\n\n        Args:\n            expression (str): The polynomial or algebraic equation for which\n                the roots are to be found, provided as a string.\n\n        Returns:\n            str: JSON string containing the roots of the expression in the\n                `\"result\"` field. The roots are represented as a list of\n                solutions. If an error occurs, the JSON string will include\n                a `\"status\"` field set to `\"error\"` and a `\"message\"` field\n                with the corresponding error description.\n\n        Raises:\n            ValueError: If the input expression is empty or contains only\n                whitespace.\n            Exception: If there is an error during the root-finding process,\n                such as invalid input, unsupported syntax, or if the equation\n                is not solvable.\n        \"\"\"\n        try:\n            self.logger.info(f\"Finding roots for expression: {expression}\")\n            if not expression.strip():\n                raise ValueError(\n                    \"Expression cannot be empty or whitespace\"\n                )  # is this necessary\n            expression = self._rewrite_expression(expression)\n            expr = sp.parse_expr(expression)\n            roots = sp.solve(expr)\n            self.logger.info(f\"Result of find roots: {roots!s}\")\n            return json.dumps({\"status\": \"success\", \"result\": str(roots)})\n\n        except Exception as e:\n            self.logger.error(\n                f\"Error finding roots for expression: {expression} - {e}\"\n            )\n            return json.dumps({\"status\": \"error\", \"message\": str(e)})",
  "differentiate": "def differentiate(\n        self, expression: str, variable: Optional[str] = None\n    ) -> str:\n        r\"\"\"Differentiates an expression with respect to a variable.\n\n        Args:\n            expression (str): The mathematical expression to differentiate,\n                provided as a string.\n            variable (str, optional): The variable with respect to which the\n                differentiation is performed. If not specified, the default\n                variable is used.\n\n        Returns:\n            str: JSON string containing the derivative of the expression in the\n                `\"result\"` field. If an error occurs, the JSON string will\n                include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the differentiation process,\n                such as invalid input, unsupported syntax, or issues with the\n                variable definition.\n        \"\"\"\n        try:\n            variable = (\n                sp.symbols(variable) if variable else self.default_variable\n            )\n            self.logger.info(\n                f\"Differentiating {expression} with respect to {variable}\"\n            )\n            expr = sp.parse_expr(expression)\n            derivative = sp.diff(expr, variable)\n            self.logger.info(f\"Result of differentiate: {derivative!s}\")\n            return json.dumps({\"result\": str(derivative)})\n        except Exception as e:\n            return self.handle_exception(\"differentiate\", e)",
  "integrate": "def integrate(\n        self, expression: str, variable: Optional[str] = None\n    ) -> str:\n        r\"\"\"Integrates an expression with respect to a variable.\n\n        Args:\n            expression (str): The mathematical expression to integrate,\n                provided as a string.\n            variable (str, optional): The variable with respect to which the\n                integration is performed. If not specified, the default\n                variable is used.\n\n        Returns:\n            str: JSON string containing the integral of the expression in the\n                `\"result\"` field. If an error occurs, the JSON string will\n                include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the integration process,\n                such as invalid input, unsupported syntax, or issues with\n                the variable definition.\n        \"\"\"\n        try:\n            variable = (\n                sp.symbols(variable) if variable else self.default_variable\n            )\n            self.logger.info(\n                f\"Integrating {expression} with respect to {variable}\"\n            )\n            expr = sp.parse_expr(expression)\n            integral = sp.integrate(expr, variable)\n            self.logger.info(f\"Result of integrate: {integral!s}\")\n            return json.dumps({\"result\": str(integral)})\n        except Exception as e:\n            return self.handle_exception(\"integrate\", e)",
  "definite_integral": "def definite_integral(\n        self, expression: str, variable: str, lower: float, upper: float\n    ) -> str:\n        r\"\"\"Computes the definite integral of an expression within given\n        bounds.\n\n        Args:\n            expression (str): The mathematical expression to integrate,\n                provided as a string.\n            variable (str): The variable with respect to which the definite\n                integration is performed.\n            lower (float): The lower limit of the integration.\n            upper (float): The upper limit of the integration.\n\n        Returns:\n            str: JSON string containing the result of the definite integral\n                in the `\"result\"` field. If an error occurs, the JSON string\n                will include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the definite integration\n                process, such as invalid input, unsupported syntax, or issues\n                with the variable or bounds.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"\"\"Computing definite integral of: {expression} \n                with respect to {variable} from {lower} to {upper}\"\"\"\n            )\n            expression = self._rewrite_expression(expression)\n            var = sp.symbols(variable)\n            expr = sp.parse_expr(expression)\n            integral = sp.integrate(expr, (var, lower, upper))\n            self.logger.info(f\"Result of definite integral: {integral!s}\")\n            return json.dumps({\"result\": str(integral)})\n        except Exception as e:\n            return self.handle_exception(\"definite_integral\", e)",
  "series_expansion": "def series_expansion(\n        self, expression: str, variable: str, point: float, order: int\n    ) -> str:\n        r\"\"\"Expands an expression into a Taylor series around a given point up\n        to a specified order.\n\n        Args:\n            expression (str): The mathematical expression to expand, provided\n                as a string.\n            variable (str): The variable with respect to which the series\n                expansion is performed.\n            point (float): The point around which the Taylor series is\n                expanded.\n            order (int): The order up to which the series expansion is\n            computed.\n\n        Returns:\n            str: JSON string containing the Taylor series expansion of the\n                expression in the `\"result\"` field. If an error occurs,\n                the JSON string will include an `\"error\"` field with the\n                corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the series expansion\n                process, such as invalid input, unsupported syntax, or\n                issues with the variable, point, or order.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"\"\"Expanding expression: {expression} \n                into Taylor series at {point} up to order {order}\"\"\"\n            )\n            expression = self._rewrite_expression(expression)\n            var = sp.symbols(variable)\n            expr = sp.parse_expr(expression)\n            series = sp.series(expr, var, point, order)\n            self.logger.info(f\"Result of series expansion: {series!s}\")\n            return json.dumps({\"result\": str(series)})\n        except Exception as e:\n            return self.handle_exception(\"series_expansion\", e)",
  "compute_limit": "def compute_limit(\n        self,\n        expression: str,\n        variable: str,\n        point: float,\n        direction: str = 'both',\n    ) -> str:\n        r\"\"\"Computes the limit of an expression as a variable approaches\n        a point.\n\n        Args:\n            expression (str): The mathematical expression for which the limit\n                is to be computed, provided as a string.\n            variable (str): The variable with respect to which the limit is\n                computed.\n            point (float): The point that the variable approaches.\n            direction (str, optional): The direction from which the limit is\n                approached. Options are `'both'`, `'+'` (right-hand limit),\n                or `'-'` (left-hand limit). Defaults to `'both'`.\n\n        Returns:\n            str: JSON string containing the computed limit of the expression\n                in the `\"result\"` field. If an error occurs, the JSON string\n                will include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the limit computation\n                process, such as invalid input, unsupported syntax, or\n                issues with the variable, point, or direction.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"\"\"Computing limit of expression: {expression} \n                as {variable} approaches {point} \n                from direction: {direction}\"\"\"\n            )\n            expression = self._rewrite_expression(expression)\n            var = sp.symbols(variable)\n            expr = sp.parse_expr(expression)\n            limit = sp.limit(expr, var, point)\n            self.logger.info(f\"Result of compute limit: {limit!s}\")\n            return json.dumps({\"result\": str(limit)})\n        except Exception as e:\n            return self.handle_exception(\"compute_limit\", e)",
  "find_critical_points": "def find_critical_points(self, expression: str, variable: str) -> str:\n        r\"\"\"Finds the critical points of an expression by setting its\n        derivative to zero.\n\n        Args:\n            expression (str): The mathematical expression for which critical\n                points are to be found, provided as a string.\n            variable (str): The variable with respect to which the critical\n                points are determined.\n\n        Returns:\n            str: JSON string containing the critical points of the expression\n                in the `\"result\"` field. The critical points are returned as a\n                list of values corresponding to the variable. If an error\n                occurs, the JSON string will include an `\"error\"` field with\n                the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the critical point\n                computation process, such as invalid input, unsupported\n                syntax, or issues with the variable or the expression.\n        \"\"\"\n        try:\n            expression = self._rewrite_expression(expression)\n            var = sp.symbols(variable)\n            expr = sp.parse_expr(expression)\n            derivative = sp.diff(expr, var)\n            critical_points = sp.solve(derivative, var)\n            return json.dumps(\n                {\"result\": [str(point) for point in critical_points]}\n            )\n        except Exception as e:\n            return self.handle_exception(\"find_critical_points\", e)",
  "check_continuity": "def check_continuity(\n        self, expression: str, variable: str, point: float\n    ) -> str:\n        r\"\"\"Checks if an expression is continuous at a given point.\n\n        Args:\n            expression (str): The mathematical expression to check for\n                continuity, provided as a string.\n            variable (str): The variable with respect to which continuity\n                is checked.\n            point (float): The point at which the continuity of the expression\n                is checked.\n\n        Returns:\n            str: JSON string containing the result of the continuity check in\n                the `\"result\"` field. The result will be `\"True\"` if the\n                expression is continuous at the given point, otherwise\n                `\"False\"`. If an error occurs, the JSON string will include\n                an `\"error\"` field with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the continuity check\n                process, such as invalid input, unsupported syntax, or\n                issues with the variable or the point.\n        \"\"\"\n        try:\n            expression = self._rewrite_expression(expression)\n            var = sp.symbols(variable)\n            expr = sp.parse_expr(expression)\n            left_limit = sp.limit(expr, var, point, dir='-')\n            right_limit = sp.limit(expr, var, point, dir='+')\n            value_at_point = expr.subs(var, point)\n            is_continuous = left_limit == right_limit == value_at_point\n            return json.dumps({\"result\": str(is_continuous)})\n        except Exception as e:\n            return self.handle_exception(\"check_continuity\", e)",
  "compute_determinant": "def compute_determinant(self, matrix: List[List[float]]) -> str:\n        r\"\"\"Computes the determinant of a matrix.\n\n        Args:\n            matrix (List[List[float]]): A two-dimensional list\n                representing the matrix for\n                which the determinant is to be computed.\n\n        Returns:\n            str: JSON string containing the determinant of the matrix in the\n                `\"result\"` field. If an error occurs, the JSON string will\n                include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the determinant computation\n                process, such as invalid input, unsupported syntax, or if the\n                matrix is not square.\n        \"\"\"\n        try:\n            self.logger.info(f\"Computing determinant of matrix: {matrix}\")\n            mat = sp.Matrix(matrix)\n            determinant = mat.det()\n            self.logger.info(f\"Result of compute determinant: {determinant!s}\")\n            return json.dumps({\"result\": str(determinant)})\n        except Exception as e:\n            return self.handle_exception(\"compute_determinant\", e)",
  "compute_inverse": "def compute_inverse(self, matrix: List[List[float]]) -> str:\n        r\"\"\"Computes the inverse of a matrix.\n\n        Args:\n            matrix (List[List[float]]): A two-dimensional list\n                representing the matrix for\n                which the inverse is to be computed.\n\n        Returns:\n            str: JSON string containing the inverse of the matrix in the\n                `\"result\"` field. The inverse is represented in a symbolic\n                matrix format. If an error occurs, the JSON string will include\n                an `\"error\"` field with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the inverse computation\n                process, such as invalid input, unsupported syntax, or if\n                the matrix is not invertible (i.e., its determinant is zero).\n        \"\"\"\n        try:\n            self.logger.info(f\"Computing inverse of matrix: {matrix}\")\n            mat = sp.Matrix(matrix)\n            inverse = mat.inv()\n            self.logger.info(f\"Result of matrix inverse: {inverse!s}\")\n            return json.dumps({\"result\": str(inverse)})\n        except Exception as e:\n            return self.handle_exception(\"compute_inverse\", e)",
  "compute_eigenvalues": "def compute_eigenvalues(self, matrix: List[List[float]]) -> str:\n        r\"\"\"Computes the eigenvalues of a matrix.\n\n        Args:\n            matrix (List[List[float]]): A two-dimensional list representing\n                the matrix for which the eigenvalues are to be computed.\n\n        Returns:\n            str: JSON string containing the eigenvalues of the matrix in the\n                `\"result\"` field. The eigenvalues are represented as a\n                dictionary where keys are the eigenvalues (as strings) and\n                values are their multiplicities (as strings). If an error\n                occurs, the JSON string will include an `\"error\"` field\n                with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the eigenvalue\n                computation process, such as invalid input, unsupported\n                syntax, or if the matrix is not square.\n        \"\"\"\n        try:\n            self.logger.info(f\"Computing eigenvalues of matrix: {matrix}\")\n            mat = sp.Matrix(matrix)\n            eigenvalues = mat.eigenvals()\n            return json.dumps(\n                {\"result\": {str(k): str(v) for k, v in eigenvalues.items()}}\n            )\n        except Exception as e:\n            return self.handle_exception(\"compute_eigenvalues\", e)",
  "compute_eigenvectors": "def compute_eigenvectors(self, matrix: List[List[float]]) -> str:\n        r\"\"\"Computes the eigenvectors of a matrix.\n\n        Args:\n            matrix (List[List[float]]): A two-dimensional list representing\n                the matrix for which the eigenvectors are to be computed.\n\n        Returns:\n            str: JSON string containing the eigenvectors of the matrix in the\n                `\"result\"` field. Each eigenvalue is represented as a\n                dictionary with the following keys:\n                - `\"eigenvalue\"`: The eigenvalue (as a string).\n                - `\"multiplicity\"`: The multiplicity of the eigenvalue\n                (as an integer).\n                - `\"eigenvectors\"`: A list of eigenvectors\n                (each represented as a string).\n\n                If an error occurs, the JSON string will include an `\"error\"`\n                field with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the eigenvector\n                computation process, such as invalid input, unsupported\n                syntax, or if the matrix is not square.\n        \"\"\"\n        try:\n            self.logger.info(f\"Computing eigenvectors of matrix: {matrix}\")\n            mat = sp.Matrix(matrix)\n            eigenvectors = mat.eigenvects()\n            result = [\n                {\n                    \"eigenvalue\": str(eigenvalue),\n                    \"multiplicity\": multiplicity,\n                    \"eigenvectors\": [str(v) for v in vectors],\n                }\n                for eigenvalue, multiplicity, vectors in eigenvectors\n            ]\n            self.logger.info(f\"Result of compute eigenvectors: {result}\")\n            return json.dumps({\"result\": result})\n        except Exception as e:\n            return self.handle_exception(\"compute_eigenvectors\", e)",
  "compute_nullspace": "def compute_nullspace(self, matrix: List[List[float]]) -> str:\n        r\"\"\"Computes the null space of a matrix.\n\n        Args:\n            matrix (List[List[float]]): A two-dimensional list\n                representing the matrix for\n                which the null space is to be computed.\n\n        Returns:\n            str: JSON string containing the null space of the matrix in the\n                `\"result\"` field. The null space is represented as a list of\n                basis vectors, where each vector is given as a string in\n                symbolic format. If an error occurs, the JSON string will\n                include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            Exception: If there is an error during the null space computation\n            process, such as invalid input, unsupported syntax, or if the\n            matrix is malformed.\n        \"\"\"\n        try:\n            self.logger.info(f\"Computing null space of matrix: {matrix}\")\n            mat = sp.Matrix(matrix)\n            nullspace = mat.nullspace()\n            return json.dumps({\"result\": [str(vec) for vec in nullspace]})\n        except Exception as e:\n            return self.handle_exception(\"compute_nullspace\", e)",
  "compute_rank": "def compute_rank(self, matrix: List[List[float]]) -> str:\n        r\"\"\"Computes the rank of a matrix.\n\n        Args:\n            matrix (List[List[float]]): A two-dimensional list\n                representing the matrix for which the rank\n                is to be computed.\n\n        Returns:\n            str: JSON string containing the rank of the matrix in the\n                `\"result\"` field. The rank is represented as an integer.\n                If an error occurs,the JSON string will include an\n                `\"error\"` field with the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the rank computation\n                process, such as invalid input, unsupported\n                syntax, or if the matrix is malformed.\n        \"\"\"\n        try:\n            self.logger.info(f\"Computing rank of matrix: {matrix}\")\n            mat = sp.Matrix(matrix)\n            rank = mat.rank()\n            self.logger.info(f\"Result of rank of matrix: {rank}\")\n            return json.dumps({\"result\": rank})\n        except Exception as e:\n            return self.handle_exception(\"compute_rank\", e)",
  "handle_exception": "def handle_exception(self, function_name: str, exception: Exception) -> str:\n        \"\"\"Handles exceptions in a consistent way across the toolkit.\n\n        Args:\n            function_name (str): Name of the function where exception occurred\n            exception (Exception): The exception that was raised\n\n        Returns:\n            str: JSON string with error information\n        \"\"\"\n        self.logger.error(\n            f\"Error in {function_name}: {str(exception)}\"\n        )\n        return json.dumps({\"status\": \"error\", \"message\": str(exception)})",
  "compute_inner_product": "def compute_inner_product(\n        self, vector1: List[float], vector2: List[float]\n    ) -> str:\n        r\"\"\"Computes the inner (dot) product of two vectors.\n\n        Args:\n            vector1 (List[float]): The first vector as a list of floats.\n            vector2 (List[float]): The second vector as a list of floats.\n\n        Returns:\n            str: JSON string containing the inner product in the\n                `\"result\"` field. If an error occurs, the JSON\n                string will include an `\"error\"` field with\n                the corresponding error message.\n\n        Raises:\n            Exception: If there is an error during the computation process,\n                    such as mismatched dimensions.\n        \"\"\"\n        try:\n            self.logger.info(\n                f\"Computing inner product of vectors: {vector1} and {vector2}\"\n            )\n            # Convert the lists into sympy Matrix objects (column vectors)\n            v1 = sp.Matrix([float(x) for x in vector1])\n            v2 = sp.Matrix([float(x) for x in vector2])\n\n            # Check that the vectors have the same dimensions.\n            if v1.shape != v2.shape:\n                raise ValueError(\n                    \"Vectors must have the same dimensions to compute\"\n                    \"the inner product.\"\n                )\n\n            # Compute the dot (inner) product.\n            inner_product = v1.dot(v2)\n            self.logger.info(f\"Result of inner product: {inner_product}\")\n\n            return json.dumps({\"result\": str(inner_product)})\n        except Exception as e:\n            return self.handle_exception(\"compute_inner_product\", e)",
  "compute_line_bisectors": "def compute_line_bisectors(self, point1: List[float], point2: List[float]) -> str:\n        r\"\"\"Computes the perpendicular bisector of a line segment.\n\n        Args:\n            point1 (List[float]): Coordinates [x, y] of the first point.\n            point2 (List[float]): Coordinates [x, y] of the second point.\n\n        Returns:\n            str: A JSON string with the \"result\" field containing the string\n                representation of the perpendicular bisector. If an error occurs,\n                the JSON string will include an \"error\" field with\n                the corresponding error message.\n        \"\"\"\n        try:\n            p1 = sp.Point(float(point1[0]), float(point1[1]))\n            p2 = sp.Point(float(point2[0]), float(point2[1]))\n            line_segment = sp.Segment(p1, p2)\n            bisector = line_segment.perpendicular_bisector()\n            return json.dumps({\"result\": str(bisector)})\n        except Exception as e:\n            return self.handle_exception(\"compute_line_bisectors\", e)",
  "matrix_multiplication": "def matrix_multiplication(\n        self, matrix1: List[List[float]], matrix2: List[List[float]]\n    ) -> str:\n        r\"\"\"Computes the matrix multiplication of two matrices.\n\n        Args:\n            matrix1 (List[List[float]]): The first matrix as a list of lists\n                of floats.\n            matrix2 (List[List[float]]): The second matrix as a list of lists\n                of floats.\n\n        Returns:\n            str: JSON string containing the result of the matrix multiplication\n                in the `\"result\"` field. If an error occurs, the JSON string\n                will include an `\"error\"` field with the corresponding error\n                message.\n\n        Raises:\n            ValueError: If the matrices are not compatible for multiplication.\n        \"\"\"\n        try:\n            # Convert the lists into sympy Matrix objects\n            m1 = sp.Matrix(matrix1)\n            m2 = sp.Matrix(matrix2)\n\n            # Check that the matrices are compatible for multiplication\n            if m1.shape[1] != m2.shape[0]:\n                raise ValueError(\n                    \"Matrices must have compatible dimensions for multiplication.\"\n                )\n\n            # Compute the matrix multiplication\n            result = m1 * m2\n            self.logger.info(f\"Result of matrix multiplication: {result!s}\")\n            return json.dumps(\n                {\"result\": str(result)}, ensure_ascii=False\n            )\n        except Exception as e:\n            return self.handle_exception(\"matrix_multiplication\", e)"
}